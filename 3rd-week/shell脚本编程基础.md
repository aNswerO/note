# 有关程序
>程序=算法+数据结构
+ 数据：程序的核心
+ 数据结构：数据在计算机中的类型和组织方式
+ 算法：处理数据的方式
# 逻辑处理方式：
+ 顺序执行：
+ 循环执行：
+ 选择执行：
# shell脚本编程：
>shell脚本：包含一些命令或声明，并符合一定格式的文本文件
# 创建脚本：
1. 使用文本编辑器创建文本文件
2. 第一行必须包括shell声明序列：如#!/bin/bash
3. #开头表示注释
# 运行脚本：
+ 给予文件执行权限，使用绝对路径或相对路径运行脚本
+ 直接运行编辑器，将脚本作为参数运行  
    eg：bash ./test.sh
## 脚本代码开头约定：
1. 第一行一般为调用使用的语言
2. 程序名，避免更改文件名为无法找到正确的文件
3. 版本号
4. 更改后的时间
5. 作者相关信息
6. 该程序的作用，及注意事项
7. 最后是各版本的更新简要说明
## 脚本调试：
```
    bash -n /PATH/TO/SCRIPT
    检测脚本中的语法错误
    bash -x /PATH/TO/SCRIPT
    调试模式执行（逐行调试运行代码，显示出脚本进行中所有的细节）
```
# 变量
>一个能存储计算结果或能表示值得抽象概念，是一个命名的可操作的内存空间
## 变量的作用：
1. 存储计算结果和数据
2. 参与运算
3. 表示数据范围
## 变量的类型：
+ 字符型
+ 数值型：整型、浮点型
## 变量的命名法则：
1. 不能使用程序中的保留字
2. 只能使用数字、下划线和字母，且不能以数字开头
3. 见名知意
4. 同意命名规则
### shell中命名建议规则：
1. 变量名大写
2. 局部变量小写
3. 函数名小写
4. 用英文名字，并体现其作用
## bash中变量的种类
+ 局部变量：仅在当前shell中生效，在其他进程（包括当前进程的子进程）均无效
    + 赋值：NAME=VALUE
    + 可以引用使用VALUE
        + 字符串：NAME="VALUE"
        + 变量引用：NAME=“$VAR”
            + 弱引用：“ ” 其中的变量引用会替换为变量值
            + 强引用：\` \`  其中的变量引用保持为原字符串，不替换成变量值
        + 命令引用：NAME=\`COMMAND\`
    + 显示已定义的所有变量：set
    + 删除变量：unset NAME
+ 只读变量：只能声明，但不能修改和删除
    + 声明：  
        readonly NAME
        declare -r NAME
    + 查看只读变量：
        readonly：-p
+ 环境变量：在当前shell和其子进程中有效
    + 变量声明与赋值：  
        export NAME=VALUE  
        declare -x name=VALUE
    + 变量引用：同局部变量
    + 显示所有环境变量：
        env、printenv、export、declare -x
    + 删除变量：unset NAME
    + bash内建环境变量：
        + PATH：系统查找命令所在的路径
        + SHELL：当前使用的shell
        + USER：当前用户
        + UID：当前用户的UID
        + HOME：当前用户的家目录
        + PWD：当前工作目录的路径
        + SHLVL：当前的shell处于第几层
        + LANG：当前使用的语言及编码格式
        + MAIL：当前用户存放邮件的路径
        + HOSTNAME：主机名
        + HISTSIZE：命令历史存放的命令上限
+ 位置变量：位置变量：$1,$2.....使shell脚本能调用从命令行传递的参数
    + 清空所有位置变量：set --
+ 本地变量：在shell脚本中某段代码生效，通常指函数
+ 特殊变量：
    + $?：最近的命令退出状态，此状态用来报告成功或失败。0代表成功，1~255代表失败。
    + $0：命令本身
    + $*：传递给脚本的所有参数，全部参数合为一个字符串
    + $@：传递给脚本的所有参数，每个参数为独立字符串
    + $#：传递给脚本的参数总数
>ps：$@与$*只有在小括号中才有差异
+ 退出状态码：
    + 自定义状态码：exit #
    >脚本执行到exit所在处会终止，退出状态码为exit设定的值  
    若未给脚本设定退出状态码，退出状态码为脚本最后一个命令的状态码
# 算术运算：
```
    +、-、*、/、%（取余）、**（乘方）
```
+ let VAR=算术表达式
+ VAR=$\[算术表达式\]
+ VAR=$((算术表达式))
+ VAR=$(expr arg1 arg2 arg3...)
+ declare -i VAR=NUMBER
+ echo ‘算术表达式’ | bc
+ bash内建的随机数生成器变量：$RANDOM%(1~32767)
>乘法符号有时需要转义
# 赋值：
```
    let VARoperVALUE
```
+ 增强型赋值：+=、-=、*=、/=、%=
# 逻辑运算：
```
    true：1  
    false:0
```
+ 非：
    !1=0
    !0=1
+ 与：  

    |与|0|1|
    |--|--|--|
    |0|0|0|
    |1|0|1|

+ 或：  

    |或|0|1|
    |--|--|--|
    |0|0|1|
    |1|1|1|
+ 短路运算：
    + 短路与：  
        第一个数为0，结果必定为0  
        第一个数为1，第二个数必须参与运算
    + 短路或：  
        第一个数为1，结果必定为1  
        第一个数为0，第二个数必须参与运算
+ 异或：异或的两个值相同为假，不同则为真
# 条件测试：
    由测试机制判断指定需求是否满足
```
    test EXPRESSION
    [ EXPRESSION ]
    [[ EXPRESSION ]]
```
>EXPRESSION为待测试的表达式，前后必须有空格；  
[ ]与[[ ]]不同，[ ]是命令，[[ ]]是Linux中的关键字。
## 数值测试：
+ -v VAR：变量VAR是否被设置(未被设置与被赋值为空为两种情况)
+ -gt：是否大于
+ -ge：是否大于等于
+ -eq：是否等于
+ -ne：是否不等于
+ -lt：是否小于
+ -le：是否小于等于
## 字符串测试：（比较ASCII码值）
+ ==：是否等于
+ \>：是否大于
+ <：是否小于
+ !=：是否不等于
+ =~：左侧字符串是否能被右侧的PATTERN所匹配（一般用于[[ ]]中）
+ -z “STRING”：字符串是否为空，空为真
+ -n “STRING”：字符串是否不空，不空为真
>用于字符串比较的操作数都应该使用引号
## 文件测试：
+ 存在性测试：
    + -e FILE：文件存在则为真，不存在则为假
+ 存在性及类别测试：
    + -b FILE：文件是否存在且为块设备文件
    + -c FILE：文件是否存在且为字符设备文件
    + -d FILE：文件是否存在且为目录文件
    + -f FILE：文件是否存在且为普通文件
    + -h|-L FILE：文件是否存在且为链接文件
    + -p FILE：文件是否存在且为命名管道文件
    + -S FILE：文件是否存在且为套接字文件
+ 存在性及文件权限测试：
    + -r FILE：是否存在且可读
    + -w FILE：是否存在且可写
    + -x FILE：是否存在且可执行
    + -u FILE：是否存在且拥有SUID权限
    + -g FILE：是否存在且拥有SGID权限
    + -t FILE：是否存在且拥有sticky权限
+ 文件属性测试：
    + 存在性及文件大小测试：
        + -s FILE：文件是否存在且非空
    + 文件是否打开：
        + -t fd：文件描述符是否在某终端被打开
        + -N FILE：文件自从上一次被读取之前是否被修改过
        + -O FILE：当前有效用户是否为文件属主
        + -G FILE：当前有效用户的主组是否为文件属组
+ 双目测试：
```
    FILE1 -ef FILE2：FILE1是否是FILE2的硬链接
    FILE1 -nt FILE2：FILE1是否新于FILE2（mtime）
    FILE1 -ot FILE2：FILE1是否新于FILE2（mtime）
```
+ 组合测试条件：
    + 第一种：
        ```
        EXPRESSION1 -a EXPRESSION2 表达式1与表达式2皆为真（逻辑与）
        EXPRESSION1 -o EXPRESSION2 俩表达式中至少一个为真（逻辑或）
        ! EXPRESSION 此表达式结果为假（逻辑非）
        ```
        >只能用测试命令[ ]执行，在[[ ]]中不能使用
    + 第二种：
        ```
        COMMAND1 && COMMAND2 短路与，代表条件性的AND THEN（当COMMAND1结果为假时，不必执行COMMAND2）
        ```




        COMMAND1 || COMMAND2 短路或俩命令至少一个为真（当COMMAND1结果为真时，不必执行COMMAND2）






        ! COMMAND 不满足此命令条件（逻辑非）
        ```
# shell脚本中括号用法：
+ 小括号：
    + 表示整体，括号内可包含逻辑
    + 后向引用
    + 在shell脚本中表示开启子进程
        ```
            (echo hello;exit)
            不会退出脚本，只会退出子进程
            { echo hello；exit； }可以退出当前进程，花括号旁的空格不能省
        ```
    + 双层小括号可以进行算术运算、逻辑运算和比较，但不能使用-a、-o、！
+ 中括号：
    + 在通配符和正则表达式中出现，表示中括号内的任意一个字符
    + 表示条件测试test
        + 双中括号可以实现复杂的逻辑运算和比较，使用=~时可以使用正则表达式，且其中匹配的字符串或通配符不需要使用引号；使用双中括号时不能使用-a、-o
        + 不含复杂逻辑运算（&&，||），单中括号就能实现，但单中括号里不能使用正则表达式
+ 花括号：
    + 在正则表达式中表示匹配之前的内容次数
    + 在shell脚本中表示不开启子进程执行命令
+ $后的括号：
    + ${a}：变量a中的值
    + $(COMMAND)：命令引用，同\`COMMAND\`
    + $((EXPR))：计算数学表达式EXPR的值，可实现复杂逻辑运算，同\`EXPR\`
# 使用read命令接收输入：
```
    read [OPTIONS] ARGUMENT[S]
    从标准输入中读取，将每个单词分配给一个变量，剩余的单词都会被分配到最后一个变量
        -p：指定要显示的提示信息
        -s：静默输入，一般用于密码
        -n #：指定输入的字符长度为#
        -d SYMBLE：指定输入结束符
        -t #：指定等待输入的时间，超过此时间则退出
```
# 条件选择
## if语句：
```
单分支：
    if 判断条件；then
        条件为真时执行的代码
    fi

双分支：
    if 判断条件；then
        条件为真时执行的代码
    else
        条件为假时执行的代码
    fi

多分支：
    if 判断条件1；then
        条件1为真时执行的代码
    elif 判断条件2；then
        条件2为真时执行的代码

    ...
    ...

    elif 判断条件N；then
        条件N为真时执行的代码
    else 
        以上条件均为假时执行的代码
    fi
```
## case语句：
```
    case 变量引用 in
    PART1)
        分支1
        ；；
    PART2)
        分支2
        ；；
    ...
    *）
        默认分支
        ；；
    esac
```
>case支持glob通配符
# bash的配置文件
+ 全局配置：
    + /etc/profile
    + /etc/profile.d/*.sh
    + /etc/bashrc
+ 个人配置：
    + ~/.bash_profile
    + ~/.bashrc
>profile类:为交互式登录的shell提供配置；用于定义环境变量、运行命令或脚本  

>bashrc类：为非交互式和交互式登录提供配置；用于定义命令别名、函数和本地变量
## 使新编辑的配置文件生效：
1. 重启shell进程
2. source 配置文件  | . 配置文件
# 登录shell的两种方式：
1. 交互式登录：
    + 直接通过终端登录
    + 使用su - USERNAME命令
    >执行顺序：/etc/profile --> /etc/profile.d/*.sh --> ~/.bash_profile --> ./bashrc --> /etc/bashrc
2. 非交互式登录：
    + 使用su USERNAME
    + 图形化界面下打开的终端
    + 执行脚本
    + 任何其他的bash实例
    >执行顺序：/etc/profile.d/*.sh --> /etc/bashrc --> ~/.bashrc
# bash退出任务：
>本文件在退出登录的shell时运行，保存在~/.bash_logout用于创建自动被封、清除临时文件
# set命令：
>用于设置shell的执行方式
```
    $-：列出当前set命令的设置
```
+ h（hashall）：打开此选项使shell将每条执行过的命令的所在路径记录下来，避免每次使用时查询
+ i（interactive）：此选项打开表示当前shell是一个交互式shell
+ m（monitor）：打开此选项可打开监控模式，此模式下可以使用job control控制进程的停止和继续、前后台执行
+ B（braceexpand）：此选项打开表示大括号扩展启用
+ H（history）：此选项打开可以展开历史列表中的命令，可使用!!返回最近的一条命令，!#可以返回上#条执行的命令
```
    set -u：在扩展一个没有被设置的变量时显示错误信息  
    set -e：如果执行的一条命令的返回值不为0（即命令执行失败）则退出
```
