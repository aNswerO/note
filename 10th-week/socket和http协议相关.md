# socket（套接字）：
+ 套接字：
    + 为通信的端点
    + 每个套接字由一个IP地址和一个端口号组成
    + 允许位于不同主机（或同一主机）上的不同进程间进行通信和数据交换
    + 通过网络通信的每一对进程需要使用一对套接字,即每个进程各有一个套接字
    + 基于C/S架构；服务器监听指定端口，等待客户请求，并在收到请求后接收并完成连接
+ Socket Domain：
    + AF_INET：IPv4地址

    + AF_INET6：IPv6地址
    + AF_UNIX：同一主机上不同进程间通信使用
+ Socket Type：
    + SOCK_STREAM：流模式；tcp套接字；可靠的传递、面向连接

    + SOCK_DGRAM：数据报模式；udp套接字；不可靠传递、无连接
    + SOCK_RAW：裸套接字；无需tcp或udp，直接通过IP包通信

# 跨网络的主机间进程通信：
1. 完成主机间通信：
    + 通信主机在同一网段：
        + 主机A（源主机）将自己的**IP地址**和**MAC地址**封装，再通过掩码计算主机B是否与自己在同一网段，若在同一网段，就在自己所处网络中发送一个**ARP广播**，此ARP请求中包含**主机A的IP地址、MAC地址**和**主机B的IP地址**

        + 主机B收到此ARP请求后，构建一个**ARP回应包**发送给主机A，此回应包中包含了**主机B的MAC地址**，至此主机间可以进行通信。

    + 通信主机不再同一网段：
        + 主机A通过掩码计算主机B与不在同一网段，主机A需要发送一个封装有自己**IP地址**和**MAC地址**的ARP广播，以此获得网关（通常为路由器）的**接收端口的MAC地址**（因为主机A与网关在同一网段，所以获取网关MAC地址的过程同上述同网段主机通信）

        + 网关收到主机A的数据包，发现目标IP并不是自己的，它不会再继续**向上**拆数据包，而是将这个数据包的**目标MAC地址**改为**下一跳路由器的接收端口的MAC地址**、**源MAC地址**改为**自己发送端口的MAC地址**，再发送给**下一跳路由器**（若途中经过多个路由器，要多次修改数据包中的源、目标MAC地址）
        + 下一跳路由器接收到数据包后，将数据包发送给目标IP主机，在反向经过上述过程，主机B会将自己的MAC地址发送给主机A，这样主机A、B就可以进行通信了

2. 完成进程间通信：
    + 进程间通信时通过套接字进行的；此连接通过一对套接字进行，即**主机A的：IP:PORT**和**主机B的：IP:PORT**

    + 主机A（客户端）的进程向主机B（服务器）发出连接请求时，主机会为该进程分配一个端口号大于等于1024的端口（小于1024的端口为系统端口或特权端口，仅管理员可用），主机A通过此套接字和主机B监听在特定端口的进程进行通信

# http服务通信时服务器和客户端都做了些什么：
1. 服务器创建套接字，并将其绑定到80端口

2. 服务器通过套接字监听80端口，并等待客户端连接
3. 客户端获取IP地址和端口号，以此创建套接字，并通过此套接字连接到服务器
4. 当客户端的连接请求发送至服务器，服务器通知应用程序有连接到来，并告知客户端连接成功；应用程序开始读取请求
5. 客户端收到连接成功的信息后，开始发送HTTP请求，并等待HTTP响应
6. 服务器的应用程序处理请求报文，处理后服务器向客户端回送HTTP响应并关闭连接
7. 客户端处理HTTP响应并关闭连接

# HTTP相关术语：
+ http：Hyper Text Transfer Protocol（超文本传输协议）

+ html：Hyper Text Markup Language（超文本标记语言）
+ CSS：Cascading Style Sheet（层叠样式表）
+ js：JavaScript
    >直译式脚本语言，一种动态类型、弱类型、基于原型的语言
+ MIME：Multipurpose Internet Mail Extensions（多用途互联网邮件扩展）
    >是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问时，浏览器会自动使用指定的应用程序打开
    + 在http中，与MIME相关的文件：/etc/mime.types
        + 格式：
        ```
            types {
                major/minor
                text/plain
                text/html
                text/css
                image/jpeg
                image/png
                video/mp4
                application/javascript
                ...
            }
        ```

# http协议：
+ http/1.0：
    + 每个TCP连接只能发送一个请求，发送数据完毕后连接就会关闭；若还需要请求其他资源，必须再新建一个连接

    + 有GET、POST、HEAD方法
    + 头信息是ASCII码，后面数据可为任何格式。服务器回应客户端时会告知客户端数据是什么格式（即Content-Type字段的作用）。这些数据类总称为MIME，每个值包括一级类型和二级类型、预定义的类型，也可自定义类型

+ http1.1：
    + 支持持久连接（persistent connection），即tcp连接默认不关闭，可被多个请求复用，不需要声明Connection：keep alive；对于同一个连接，大多数浏览器允许同时建立6个持久连接

    + 支持管道机制（pipelining），即在同一个tcp连接中，客户端可以同时发送多个请求，进一步提高了http协议的效率
    + 有GET、POST、HEAD、PUT、PATCH、OPTIONS、DELETE
    + 同一个TCP连接里，所有的数据通信都是按次序进行的；服务器只能顺序处理回应，若前面的回应慢，会造成“队头堵塞”（Head-of-line blocking）
        + 避免队头堵塞的两种措施：
            1. 减少请求数
            2. 同时多开持久连接
    + http协议不带有状态，每次请求都必须附上所有信息；由于请求的很多字段都是重复的，因此浪费了带宽，影响速度
+ http1.0和http1.1的区别：

    ||http1.0|http1.1|
    |-----|-------|----|
    |缓存处理|主要使用header（头部）中的If-Modified-Since,Expires作为缓存判断的标准|引入了更多的缓存控制策略如Entity tag，If-Unmodified-Since, If-Match，If-None-Match等更多可供选择的**缓存头**来控制缓存策略|
    |带宽优化及网络连接的使用|不支持断点续传，存在带宽浪费的现象|在**请求头部**引入了**range头域**，允许只请求资源的某个部分，方便了开发者自由选择以充分利用带宽和连接；返回码为206|
    |错误通知的管理|未定义任何1XX响应状态码|新增了24个响应状态码|
    |Host头处理|认为每台服务器都绑定了唯一的一个IP地址，所以请求消息中的URL没有传递主机名|请求消息和响应消息都支持**Host头域**；请求消息中若没有**Host头域**会报告一个错误，响应状态码400（Bad Request）|
    |长连接|不支持|支持长连接（PresistentConnection）和请求的流水线处理（Pipelining）；在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟；默认开启了Connection：keep-alive，弥补了http1.0每次请求都要创建连接的缺点
+ http1.x现存的问题：
    + http1.x在传输数据时，每次都需要重新建立连接，增大了大量的延时时间

    + http1.x在传输数据时，所有传输的内容都是明文，客户端和服务器无法验证对方身份，安全性无法保证
    + http1.x在使用时，header里携带的内容过多，且每次请求header基本没什么变化，增加了传输的成本
    + 虽然支持了keep-alive可以弥补多次创建连接产生的延迟，但对于单个文件被不断请求的服务（如图片存放网站）滥用长连接会极大地影响性能，因为在文件被请求之后还保持了长时间的不必要的连接
# https协议：
>解决http协议的安全问题
+ https协议需要到CA申请证书

+ http协议运行于TCP协议之上，所有传输的内容都是明文，https运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输内容都是经过加密的
+ http与https服务器使用的端口不同，http为80，https为443
+ https可有效地防止运营商劫持
+ 虽然https中的**SSL握手**等过程会影响访问速度，但经过合理的优化和部署后，https对速度的影响仍在接受范围内
# http的工作机制：
+ 一次http事务：
    + http request：http请求

    + http response：http响应
+ web资源：web resource
    >一个web网页由多个资源构成，打开一个页面会有多个资源展示，但是每个资源都要单独请求
    + 静态资源：无需服务器做出额外处理，服务器从内存中读取相应的文件返回给客户端，客户端通过**解析和渲染**显示出来
        + 文件后缀：.html、.txt、.jpeg、.jss、.css、.mp3...

    + 动态资源：由服务器执行程序进行处理，将处理后的结果返回给客户端
        + 文件后缀：.php、.jsp、.asp
+ 提高连接性能的方式：
    + 并行连接：通过多条TCP连接发起并发的http请求

    + 持久连接：keep-alive，长连接；重用TCP连接，以消除连接和关闭的时延，以事务的个数和持续时间来决定是否关闭连接
    + 管道化连接：通过共享TCP连接发起并发的http请求
    + 复用的连接：交替传送请求和响应报文（处于实验阶段）
# URI：
+ URI：Uniform Resource Identifier（统一资源标识）
    >URN定义某事物的身份，URL提供了查找该事物的方法；URN只用于命名而不指定地址
    + URN：Uniform Resource Naming（统一资源命名）：用特定的命名空间的名字标识资源；使用URN可以四处迁移资源，且不用担心资源迁移后无法访问

    + URL：Uniform Resorce Locator（统一资源定位符）：不仅标识了web资源，还指定了操作或获取方式，同时指出了访问机制和网络位置
+ 示例：
    + URI：
        + 这是一个URI：
        ```
        https://www.baidu.com/index.html/#intro
        ```
        + 下面是访问资源的方式，即协议：
        ```
        https://
        ```
        + 下面是资源存放的位置：
        ```
        www.baidu.com/index.html
        ```
        + 下面是资源：
        ```
        #intro
        ```
    + 上例中的URL：
        ```
        https://www.baidu.com/index.html
        ```
        + URL的组成：
            ```html
            <schema>://<usr>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>

            <!--
            <schema>：方案；访问服务器以获取资源时要使用的协议
            <user>：用户；有些方案访问资源时需要的用户名
            <password>：密码；上面提到的用户对应的密码，用户与密码间使用":"分隔
            <host>：主机；资源宿主服务器的主机名或者IP地址
            <port>：端口；资源宿主服务器正在监听的端口号，很多方案有特定的端口号
            <path>：路径；服务器资源的本地名，由一个"/"将其与前面的URL组件分隔
            <params>：参数；指定输入的参数，参数格式为“NAME/VALUE”；多个参数间用";"隔开
            <query>：查询；传递参数给程序；与之前的URL组件用"?"分隔；多个查询间用"&"分隔
            <frag>：片段；一小片或一小部分资源的名字，此组件在客户端使用，用"#"与之前的URL组件分隔
            -->
            ```
    + 上例中的URN:
        ```
        www.baidu.com/index.html/#intro
        ```
